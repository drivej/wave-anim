{"version":3,"file":"index.js","sources":["../src/audio-wave/AudioWave.ts","../src/wave-builder/CanvasClipboard.js","../src/wave-builder/WaveCanvas.js","../src/WaveAnimReact.tsx"],"sourcesContent":["import { Howl, Howler } from 'howler';\nimport { debounce } from 'lodash';\nimport { action, makeObservable, observable } from 'mobx';\nimport { IAudioWave, WaveModel } from './IAudioPlayer';\n/*\n\nThere's a balance between the WAVE_FPS (frames per second) of the analyser node render, the analyser SMOOTHING_TIME_CONSTANT, and the css:transition that shows the wave\nWe can get away with a low frame rate by animating the transition in the wave\nTheoretically, the sound processing is more intensive than the animation\n\n*/\nconst debug = true;\n\nconst MIN_WAVE_ARRAY_LENGTH = 64;\nconst DEFAULT_WAVE = Array(MIN_WAVE_ARRAY_LENGTH).fill(0);\nconst WAVE_FPS = 10;\nconst SMOOTHING_TIME_CONSTANT = 0.85;\nconst MIN_DECIBELS = -80;\nconst MAX_DECIBELS = -10;\nconst FFT_SIZE = Math.pow(2, 11); //512;\n\nexport class AudioWave implements IAudioWave {\n  source!: MediaElementAudioSourceNode;\n  analyserNode: AnalyserNode | undefined;\n  gainNode!: GainNode | undefined;\n  buffer!: AudioBuffer;\n  bufferData: unknown;\n  bufferLength = 0;\n  dataArray: Uint8Array<ArrayBuffer> = new Uint8Array();\n  wave: WaveModel = DEFAULT_WAVE;\n  fullWave: WaveModel = DEFAULT_WAVE;\n  tickTimeout!: NodeJS.Timeout;\n  requestFrame!: number;\n  built = false;\n  nodesConnected = false;\n  howl!: Howl & { _sounds?: { _node: GainNode & { bufferSource: AudioBufferSourceNode } }[] };\n  howlId = -1;\n  src = '';\n  loaded = false;\n  isLoading = false;\n  shouldPlay = false;\n  throttle = 100;\n  isMuted = false;\n  isLocked = true;\n\n  constructor() {\n    makeObservable(this, {\n      wave: observable,\n      fullWave: observable,\n      getWaveData: action,\n      updateWave: action,\n      seek: action.bound,\n      tick: action.bound,\n      resetWave: action,\n      loaded: observable,\n      isLoading: observable,\n      isMuted: observable,\n      toggleMute: action.bound,\n      setMute: action.bound,\n      shouldPlay: observable,\n      isLocked: observable\n    });\n\n    // Check if audio context is already unlocked\n    if (Howler.ctx && Howler.ctx.state === 'running') {\n      this.isLocked = false;\n    }\n  }\n\n  resetWave(): void {\n    this.wave = DEFAULT_WAVE;\n    this.fullWave = DEFAULT_WAVE;\n  }\n\n  setSource(src: string): void {\n    if (this.src === src) return;\n    this.src = src;\n    this.loaded = false;\n    this.isLoading = true;\n    if (debug) console.log('wave.setSource()');\n\n    // Stop and unload previous audio\n    this.stopTick();\n    if (this.howl) {\n      this.howl.stop();\n      this.howl.unload();\n    }\n    this.resetWave();\n    this.nodesConnected = false;\n    this.built = false;\n\n    this.howl = new Howl({\n      src: src,\n      autoplay: false,\n      mute: false,\n      html5: false, // Use Web Audio API for better control\n      onplay: () => {\n        if (debug) console.log('howl.onplay, shouldPlay:', this.shouldPlay);\n        if (this.shouldPlay) {\n          this.buildNodes();\n          this.hijackBuffer();\n          this.startTick();\n        } else {\n          this.pause();\n        }\n      },\n      onpause: () => {\n        if (debug) console.log('howl.onpause, shouldPlay:', this.shouldPlay);\n        if (!this.shouldPlay) {\n          this.stopTick();\n        } else {\n          this.play();\n        }\n      },\n      onload: action(() => {\n        if (debug) console.log('howl.onload, shouldPlay:', this.shouldPlay);\n        this.fullWave = this.getFullWave();\n        this.loaded = true;\n        this.isLoading = false;\n        if (this.shouldPlay) {\n          this.play();\n        }\n        // Check if already unlocked after load\n        if (Howler.ctx && Howler.ctx.state === 'running') {\n          this.isLocked = false;\n        }\n      }),\n      onend: action(() => {\n        if (debug) console.log('howl.onend');\n        this.wave = DEFAULT_WAVE;\n        this.shouldPlay = false;\n      }),\n      onunlock: action(() => {\n        if (debug) console.log('unlock');\n        this.isLocked = false;\n      })\n    });\n\n    // Create a single sound instance and keep its ID\n    this.howlId = this.howl.play();\n    this.howl.pause(this.howlId);\n\n    // Check if already unlocked after creating Howl\n    if (Howler.ctx && Howler.ctx.state === 'running') {\n      this.isLocked = false;\n    }\n  }\n\n  play = debounce(() => {\n    if (!this.howl) return;\n    if (debug) console.log('wave.play(), howlId:', this.howlId);\n    this.shouldPlay = true;\n\n    // If the sound is already playing, don't create a new one\n    if (this.howl.playing(this.howlId)) {\n      if (debug) console.log('already playing, skipping');\n      return;\n    }\n\n    // Resume the existing sound\n    this.howl.play(this.howlId);\n    this.buildNodes();\n    this.hijackBuffer();\n\n    // Check if unlock happened after play attempt\n    setTimeout(() => {\n      if (Howler.ctx && Howler.ctx.state === 'running' && this.isLocked) {\n        this.isLocked = false;\n      }\n    }, 100);\n  }, 50);\n\n  pause(): void {\n    if (!this.howl) return;\n    if (debug) console.log('wave.pause(), howlId:', this.howlId);\n    this.shouldPlay = false;\n    this.stopTick();\n    this.play?.cancel();\n    this.howl.pause(this.howlId);\n  }\n\n  togglePlay(): void {\n    this.shouldPlay ? this.pause() : this.play();\n  }\n\n  toggleMute(): void {\n    this.isMuted = !this.isMuted;\n    this.updateGain();\n  }\n\n  setMute(muted: boolean): void {\n    this.isMuted = muted;\n    this.updateGain();\n  }\n\n  updateGain(): void {\n    if (this.gainNode) {\n      this.gainNode.gain.setValueAtTime(this.isMuted ? 0 : 1, Howler.ctx.currentTime);\n    }\n  }\n\n  seek(position = 0): void {\n    if (debug) console.log('wave.seek()');\n    this.howl.pause(this.howlId);\n    this.howl.seek(position, this.howlId);\n  }\n\n  setPlaybackRate(n: number): void {\n    this.howl.rate(n, this.howlId);\n  }\n\n  startTick(): void {\n    this.stopTick();\n    this.tick();\n  }\n\n  tick(): void {\n    this.tickTimeout = setTimeout(() => {\n      this.updateWave();\n      this.requestFrame = requestAnimationFrame(this.tick);\n    }, this.throttle / WAVE_FPS);\n  }\n\n  stopTick(): void {\n    if (this.tickTimeout) clearTimeout(this.tickTimeout);\n    if (this.requestFrame) cancelAnimationFrame(this.requestFrame);\n  }\n\n  hijackBuffer(): void {\n    // the trickery here is to capture the wave before the volume so the wave will show even if the volume is 0 or muted\n    if (debug) console.log('hijackBuffer');\n    const node = this.howl._sounds?.[0]?._node;\n    node?.bufferSource?.disconnect();\n    node?.bufferSource?.connect(this.analyserNode!);\n\n    // Only connect analyser and gain nodes once to avoid multiple audio streams\n    if (!this.nodesConnected) {\n      this.analyserNode?.connect(this.gainNode!);\n      this.gainNode?.connect(Howler.ctx.destination);\n      this.nodesConnected = true;\n    }\n  }\n\n  buildNodes(): void {\n    if (!this.built) {\n      if (debug) console.log('buildNodes');\n      this.built = true;\n      this.analyserNode = Howler.ctx.createAnalyser();\n      this.analyserNode.minDecibels = MIN_DECIBELS;\n      this.analyserNode.maxDecibels = MAX_DECIBELS;\n      this.analyserNode.smoothingTimeConstant = SMOOTHING_TIME_CONSTANT;\n      this.analyserNode.fftSize = FFT_SIZE;\n      this.bufferLength = this.analyserNode.frequencyBinCount;\n      this.dataArray = new Uint8Array(this.bufferLength);\n      this.gainNode = Howler.ctx.createGain();\n      // Initialize gain based on current mute state\n      this.gainNode.gain.setValueAtTime(this.isMuted ? 0 : 1, Howler.ctx.currentTime);\n    }\n  }\n\n  updateWave(): void {\n    this.wave = this.getWaveData();\n  }\n\n  getRawWave() {\n    this.analyserNode!.getByteFrequencyData(this.dataArray);\n    return this.dataArray;\n  }\n\n  getWaveData(): WaveModel {\n    if (this.analyserNode) {\n      this.analyserNode.getByteFrequencyData(this.dataArray);\n      // return this.dataArray;\n      let i = this.dataArray.length;\n      // trim off zeros at the end of this array to focus on the active part of the wave\n      while (i-- && i > MIN_WAVE_ARRAY_LENGTH && this.dataArray[i] === 0);\n      // convert array values from 0-255 int to 0-1 float\n      return Array.from(this.dataArray.slice(0, i)).map((n: number) => n / 255);\n    }\n    return DEFAULT_WAVE;\n  }\n\n  getFullWave(samples = 500): WaveModel {\n    // ref: https://css-tricks.com/making-an-audio-waveform-visualizer-with-vanilla-javascript/\n    const node = this.howl._sounds?.[0]?._node;\n    const buffer = node?.bufferSource?.buffer;\n    if (!buffer) return DEFAULT_WAVE;\n    const a = buffer.getChannelData(0);\n    const chunkSize = Math.floor(a.length / samples);\n\n    let chunks = [];\n    let i = 0;\n    let ii = 0;\n    let sum = 0;\n    let chunkStart = 0;\n    const abs = Math.abs;\n\n    for (i = 0; i < samples; i++) {\n      sum = 0;\n      chunkStart = chunkSize * i;\n      for (ii = 0; ii < chunkSize; ii++) {\n        sum += abs(a[chunkStart + ii]);\n      }\n      chunks.push(sum / chunkSize);\n    }\n\n    const multiplier = Math.pow(Math.max(...chunks), -1);\n    chunks = chunks.map((n: number) => n * multiplier);\n\n    // was one scenario where all values were coming back as NaN - who knows but here's a cheap check for it\n    if (isNaN(chunks[0])) {\n      chunks = DEFAULT_WAVE;\n    }\n    return chunks;\n  }\n\n  destroy(): void {\n    if (debug) console.log('AudioWave destroy');\n    this.howl.stop();\n    return;\n    \n    this.stopTick();\n    this.pause();\n    if (this.howl) {\n      this.howl.stop();\n      this.howl.unload();\n    }\n    // cleanup analyser node\n    if (this.analyserNode) {\n      this.analyserNode.disconnect();\n      this.analyserNode = undefined;\n    }\n    // cleanup gain node\n    if (this.gainNode) {\n      this.gainNode.disconnect();\n      this.gainNode = undefined;\n    }\n    this.resetWave();\n    this.nodesConnected = false;\n    this.built = false;\n  }\n}\n","export default class CanvasClipboard {\n  $cvs;\n  ctx;\n  width;\n  height;\n\n  constructor() {\n    this.$cvs = document.createElement('canvas');\n    this.ctx = this.$cvs.getContext('2d', { alpha: true, desynchronized: true });\n    this.setSize(100, 100);\n  }\n\n  clear() {\n    this.ctx.clearRect(0, 0, this.width, this.height);\n  }\n\n  setSize(w, h) {\n    this.width = w;\n    this.height = h;\n    this.$cvs.width = w;\n    this.$cvs.height = h;\n  }\n}\n","import CanvasClipboard from './CanvasClipboard';\n\nexport default class WaveCanvas {\n  clipboard = new CanvasClipboard();\n  overlay = new CanvasClipboard();\n  $cvs;\n  ctx;\n  wave = [];\n  nextWave = Array(128).fill(0);\n  requestFrame;\n  scaleDeltaX = 1.0;\n  scaleDeltaY = 1.0;\n  fadeRate = 0.85;\n  width = 1;\n  height = 1;\n  waveColor = '#ffcb77';\n  hue = 45;\n\n  constructor(config) {\n    if(config?.waveColor) this.waveColor = config.waveColor;\n    this.$cvs = document.createElement('canvas');\n    this.ctx = this.$cvs.getContext('2d', { alpha: true, desynchronized: true });\n    this.$clipboard = document.createElement('canvas');\n    this.clipboard_ctx = this.$clipboard.getContext('2d', { alpha: true, desynchronized: true });\n    this.setSize(500, 200);\n  }\n\n  clear() {\n    let cw = this.$cvs.width;\n    let ch = this.$cvs.height;\n    // this.ctx.clearRect(0, 0, cw, ch);\n    // return;\n\n    this.ctx.save();\n    let nw = cw * this.scaleDeltaX;\n    let nh = ch * this.scaleDeltaY;\n    let nx = (cw - nw) * 0.5;\n    let ny = (ch - nh) * 0.5;\n    let blur = 1.1;\n\n    this.ctx.globalAlpha = this.fadeRate;\n    this.ctx.filter = `blur(${blur}px) hue-rotate(${this.hue}deg)`;\n\n    this.clipboard.clear();\n    this.clipboard.ctx.drawImage(this.$cvs, 0, 0);\n\n    this.ctx.clearRect(0, 0, cw, ch);\n    this.ctx.drawImage(this.clipboard.$cvs, 0, 0, cw, ch, nx, ny, nw, nh);\n    this.ctx.restore();\n  }\n\n  drawOverlay() {\n    this.overlay.clear();\n    let h = this.overlay.height;\n    let w = this.overlay.width;\n    let barW = 2;\n    this.overlay.ctx.fillStyle = '#000';\n    for (var i = 0; i < w; i += barW * 2) {\n      this.overlay.ctx.fillRect(i, 0, barW, h);\n    }\n  }\n\n  draw(wave) {\n    this.clear();\n    var w = this.$cvs.width;\n    var h = this.$cvs.height;\n    var cy = h * 0.5;\n    var stepX = w / wave.length;\n    let i = wave.length;\n    let n, x, y, eh, ey;\n\n    this.clipboard.clear();\n    this.clipboard.ctx.fillStyle = this.waveColor;\n    this.clipboard.ctx.beginPath();\n    this.clipboard.ctx.moveTo(w, cy);\n\n    while (i--) {\n      n = wave[i];\n      x = Math.round(i * stepX);\n      eh = n * h;\n      ey = cy - eh * 0.5;\n      this.clipboard.ctx.lineTo(x, ey);\n    }\n    this.clipboard.ctx.lineTo(0, cy);\n    this.clipboard.ctx.closePath();\n    this.clipboard.ctx.fill();\n\n    this.ctx.drawImage(this.clipboard.$cvs, 0, 0, w, cy, 0, 0, w, cy);\n    this.ctx.translate(0, h - 1);\n    this.ctx.scale(1, -1);\n    this.ctx.drawImage(this.clipboard.$cvs, 0, 0, w, cy, 0, 0, w, cy);\n\n    // this.ctx.drawImage(this.overlay.$cvs, 0, 0);\n  }\n\n  drawBlob(wave, clipIndex) {\n    this.clear();\n    var w = this.$cvs.width;\n    var h = this.$cvs.height;\n    var stepX = w / clipIndex;\n    let i = -1;\n    let n, x, y, eh, ey;\n\n    this.clipboard.clear();\n    this.clipboard.ctx.fillStyle = '#fff';\n    this.clipboard.ctx.beginPath();\n    this.clipboard.ctx.moveTo(0, h * 0.5);\n\n    while (i++ < clipIndex) {\n      n = wave[i];\n      x = Math.round(i * stepX);\n      eh = (n / 255) * h;\n      ey = h * 0.5 - eh * 0.5;\n      this.clipboard.ctx.lineTo(x, ey);\n    }\n    this.clipboard.ctx.lineTo(w, h * 0.5);\n    this.clipboard.ctx.closePath();\n    this.clipboard.ctx.fill();\n\n    this.ctx.drawImage(this.clipboard.$cvs, 0, 0, w, h * 0.5, 0, 0, w, h * 0.5);\n    this.ctx.translate(0, h - 1);\n    this.ctx.scale(1, -1);\n    this.ctx.drawImage(this.clipboard.$cvs, 0, 0, w, h * 0.5, 0, 0, w, h * 0.5);\n  }\n\n  setSize(w, h) {\n    this.width = w;\n    this.height = h;\n    this.clipboard.setSize(w, h);\n    this.clipboard.ctx.drawImage(this.$cvs, 0, 0, this.width, this.height, 0, 0, w, h);\n    this.$cvs.width = w;\n    this.$cvs.height = h;\n    this.ctx.drawImage(this.clipboard.$cvs, 0, 0);\n    this.ctx.fillStyle = this.waveColor;\n    this.overlay.setSize(w, h);\n    this.drawOverlay();\n  }\n}\n","import { reaction } from 'mobx';\nimport React, { forwardRef, useEffect, useImperativeHandle, useRef, useState } from 'react';\nimport { AudioWave } from './audio-wave/AudioWave.js';\nimport WaveCanvas from './wave-builder/WaveCanvas.js';\n\nexport interface WaveAnimReactProps extends React.HTMLAttributes<HTMLDivElement> {\n  width: number;\n  height: number;\n  audioSrc?: string;\n}\n\nexport type WaveAnimHandle = {\n  play: () => void;\n  pause: () => void;\n  togglePlay: () => void;\n  toggleMute: () => void;\n  setMute: (muted: boolean) => void;\n  isPlaying: boolean;\n  isMuted: boolean;\n  isLocked: boolean;\n  destroy: () => void;\n  subscribe: (callback: (state: { isPlaying: boolean; isMuted: boolean; isLocked: boolean }) => void) => () => void;\n};\n\nexport const WaveAnimReact = forwardRef<WaveAnimHandle, WaveAnimReactProps>(({ width, height, className, style, audioSrc, ...rest }, ref) => {\n  const audioWave = useRef(new AudioWave());\n  const waveCanvas = useRef(new WaveCanvas());\n  const containerRef = useRef<HTMLDivElement>(null);\n\n  useImperativeHandle(ref, () => ({\n    play: () => audioWave.current.play(),\n    pause: () => audioWave.current.pause(),\n    togglePlay: () => audioWave.current.togglePlay(),\n    toggleMute: () => audioWave.current.toggleMute(),\n    setMute: (muted: boolean) => audioWave.current.setMute(muted),\n    destroy: () => audioWave.current.destroy(),\n    get isPlaying() {\n      return audioWave.current.shouldPlay;\n    },\n    get isMuted() {\n      return audioWave.current.isMuted;\n    },\n    get isLocked() {\n      return audioWave.current.isLocked;\n    },\n    subscribe: (callback) => {\n      const disposePlay = reaction(\n        () => audioWave.current.shouldPlay,\n        () =>\n          callback({\n            isPlaying: audioWave.current.shouldPlay,\n            isMuted: audioWave.current.isMuted,\n            isLocked: audioWave.current.isLocked\n          })\n      );\n\n      const disposeMute = reaction(\n        () => audioWave.current.isMuted,\n        () =>\n          callback({\n            isPlaying: audioWave.current.shouldPlay,\n            isMuted: audioWave.current.isMuted,\n            isLocked: audioWave.current.isLocked\n          })\n      );\n\n      const disposeLock = reaction(\n        () => audioWave.current.isLocked,\n        () =>\n          callback({\n            isPlaying: audioWave.current.shouldPlay,\n            isMuted: audioWave.current.isMuted,\n            isLocked: audioWave.current.isLocked\n          })\n      );\n\n      // Return unsubscribe function\n      return () => {\n        disposePlay();\n        disposeMute();\n        disposeLock();\n      };\n    }\n  }));\n\n  // Init/attach canvases once\n  useEffect(() => {\n    const container = containerRef.current;\n    if (!container) return;\n\n    // Ensure container is empty (prevents duplicate canvases)\n    container.innerHTML = '';\n\n    waveCanvas.current.setSize(width, height);\n    container.appendChild(waveCanvas.current.$cvs);\n    container.appendChild(waveCanvas.current.overlay.$cvs);\n\n    // Put cursor on container (since overlay won't receive pointer events)\n    container.style.cursor = 'pointer';\n\n    // Overlay should not block clicks\n    Object.assign(waveCanvas.current.overlay.$cvs.style, {\n      position: 'absolute',\n      inset: '0',\n      width: '100%',\n      height: '100%',\n      pointerEvents: 'none'\n    });\n\n    // Optional: make sure base canvas fills container\n    Object.assign(waveCanvas.current.$cvs.style, {\n      position: 'absolute',\n      inset: '0',\n      width: '100%',\n      height: '100%'\n    });\n  }, []); // only once\n\n  // Keep size updated\n  useEffect(() => {\n    waveCanvas.current.setSize(width, height);\n  }, [width, height]);\n\n  // Audio source setup + mobx reactions with cleanup\n  useEffect(() => {\n    if (!audioSrc) return;\n\n    audioWave.current.setSource(audioSrc);\n    audioWave.current.pause();\n    audioWave.current.setMute(true);\n\n    const disposeWave = reaction(\n      () => audioWave.current.wave,\n      (wave) => {\n        waveCanvas.current.draw(wave);\n      }\n    );\n\n    return () => {\n      disposeWave();\n      audioWave.current.destroy();\n    };\n  }, [audioSrc]);\n\n  return (\n    <div\n      ref={containerRef}\n      className={className}\n      {...rest}\n      style={{\n        backgroundColor: '#121212',\n        width: `${width}px`,\n        height: `${height}px`,\n        position: 'relative',\n        overflow: 'hidden',\n        ...style\n      }}\n    />\n  );\n});\n\nexport const useWaveControls = (waveRef: React.RefObject<WaveAnimHandle>) => {\n  const [isLocked, setIsLocked] = useState(true);\n  const [isMuted, setIsMuted] = useState(true);\n  const [isPlaying, setIsPlaying] = useState(false);\n\n  useEffect(() => {\n    if (!waveRef.current) return;\n    setIsLocked(waveRef.current.isLocked);\n    setIsMuted(waveRef.current.isMuted);\n    setIsPlaying(waveRef.current.isPlaying);\n    waveRef.current.setMute(false);\n    const unsubscribe = waveRef.current.subscribe((state) => {\n      setIsPlaying(state.isPlaying);\n      setIsMuted(state.isMuted);\n      setIsLocked(state.isLocked);\n    });\n    return unsubscribe;\n  }, [waveRef]);\n\n  return {\n    isLocked, //\n    isMuted,\n    isPlaying,\n    togglePlay: waveRef.current?.togglePlay,\n    toggleMute: waveRef.current?.toggleMute,\n    destroy: waveRef.current?.destroy,\n    play: waveRef.current?.play,\n    pause: waveRef.current?.pause\n  };\n};\n"],"names":["MIN_WAVE_ARRAY_LENGTH","DEFAULT_WAVE","WAVE_FPS","SMOOTHING_TIME_CONSTANT","MIN_DECIBELS","MAX_DECIBELS","FFT_SIZE","AudioWave","debounce","Howler","makeObservable","observable","action","src","Howl","muted","position","n","node","i","samples","buffer","a","chunkSize","chunks","ii","sum","chunkStart","abs","multiplier","CanvasClipboard","w","h","WaveCanvas","config","cw","ch","nw","nh","nx","ny","blur","barW","wave","cy","stepX","x","eh","ey","clipIndex","WaveAnimReact","forwardRef","width","height","className","style","audioSrc","rest","ref","audioWave","useRef","waveCanvas","containerRef","useImperativeHandle","callback","disposePlay","reaction","disposeMute","disposeLock","useEffect","container","disposeWave","jsx","useWaveControls","waveRef","isLocked","setIsLocked","useState","isMuted","setIsMuted","isPlaying","setIsPlaying","state"],"mappings":"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"}